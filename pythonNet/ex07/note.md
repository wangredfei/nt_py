# 共享内存
- 通信原理:在内存中开辟一个区域,对多进程可见,  
    进程可以写入内容或读取内容,  
    但是每次写入的内容都会覆盖之前的内容
## `from multiprocessing import Value,Array`

## `obj = Value(ctype,data)`
- 功能: 开辟共享内存
- 参数: 
    - ctype : 字符串 表示共享内存中的数据类型
        - 常用格式: 
            - int --> i
            - float --> f
            - char(bytes) --> c
    - data : 初始化存入数据

- obj.value 属性, 即共享内存的值 ---> 对该属性的读取和修改  | 即修改共享内存

## `obj = Array(ctype,obj)`
- 功能: 创建共享内存
- 参数:
    - ctype 要存储的数据类型
    - obj 列表(字符串)  表示共享内存中初始数据 空间结构的大小
- 返回值 : 共享内存对象

* 可以通过循环遍历或者[]序列号方式获取共享内存值,或改写共享内存值
* 如果共享内存中是字节串,可以通过obj.value获取该子串


# 差别
--- | 管道| 消息队列| 共享内存
---|---|---|---
开辟空间|内存| 内存| 内存
读写方式|两端读写|先进先出| 覆盖之前的内容
效率| 一般|一般|较高
使用特点| 父子进程|第三方库|注意争夺内存

# 信号量(信号灯)
- 原理: 给定一个数量,对多个进程可见,多个进程可以通过方法操作这个数量,达到协同工作的目的

## `from multiprocessing import Semaphore`

## `sem = Semaphore(num)`
- 功能: 创建信号量
- 参数: 初始化信号量
- 返回值: 信号量对象
## `sem.acquire()`
- 功能: 将消耗一个信号量,当信号量为0会阻塞

## `sem.release()`
- 功能: 增加一个信号量资源

## `sem.get_value()`
- 功能: 获取信号量资源数量



# 多任务编程之线程 (Thread)
- 什么是线程
    1. 线程也是多任务编辑方法
    2. 线程也可以使用计算机多核资源
    3. 线程被称为轻量级的进程,也是运行状态的概念
    4. 一个进程中可以包含多个线程, 线程是进程的一部分
    5. 线程是系统分配内核的最小单位
- 特征
    1. 线程也是运行状态,有生命周期,消耗计算机资源
    2. 多个线程之间独立运行互不干扰
    3. 一个进程内的线程共享进程资源
    4. 线程的创建删除消耗的系统资源圆圆小于进程1/20
    5. 线程也有子集独立的资源,栈空间,命令集,ID等

## threading 模块创建线程

## `from threading import Thread`
- 功能 : 创建线程对象
- 参数 :
    - target 绑定线程函数
    - args 元组 给线程函数传参
    - kwargs 字典 给线程函数传参
    - name 线程名 默认 Thread-1
## `t.start()` 启动线程,自动运行线程函数
## `t.join()` 阻塞等待回收线程

## 线程对象属性
- t. name    线程名称
- t.setName 设置名称
- t.getName 获取名称
- t.is_alive() 线程状态
- threading.currentThread() 获取当前线程对象

- t.daemon 
    - 默认为False此时主线程退出分支线程继续执行
    - 如果设置为True则主线程退出分支线程也退出
- t.setDaemon(True) 设置Daemon属性
- t.isDaemon() 查看daemon属性
- 在start前面设置,通常不和join()同用

# 自定义线程类
- 继承Tread类
- 添加自己的属性__init__,需要加载父类__init__属性
- 重写run方法
- 使用自己的类生成线程对象
- 调用start()会自动以一个线程执行run

# 线程的通信
- 通信方法: 使用进程空间中的全局变量通信
- 注意事项
    - 共享资源争夺,往往需要同步互斥机制协调

## 线程同步互斥
- 共享资源(临界资源): 多个线程都可以操作的资源称为共享资源
- 临界区: 指一段代码,对临界资源操作的代码段
- 同步: 同步是一种合作关系,为完成任务,多个进程或者线程之间形成一种协调调度,按照必要的步骤有序执行一系列操作
- 互斥: 互斥是一种制约关系,当一个进程或者线程使用临界资源时会进行加锁处理,此时另一个进程或者线程就无法操作,直到解锁后才能操作

## 线程同步互斥方法
- 线程Event
### `e = Event()`
- 创建事件对象(事件对象初始为未设置状态)
### `e.wait([timeout])`
- 如果e是未设置的状态则阻塞,如果e是被设置状态则不阻塞
- 参数: timeout 超时事件 
### `e.set()`
- 将e变为被设置状态
### `e.clear()`
- 清楚e的设置
### `e.is_set()`
- 判断当前e的状态, 设置为--> True  /未设置为False


## 线程锁 LOCK

### `from threading import Lock`

### `lock = Lock()`
- 创建锁对象
### `lock.acquire()`
- 上锁, 如果已经上锁调用该函数阻塞
### `lock.release()`
- 解锁

## python 线程的GIL问题(全局解释器锁)
- 由于python解释器中加入了全局解释器锁,导致python解释器同一时刻只能解释一个线程,所以大大降低了python多线程的执行效率
- 后果: python线程一般只能用在大量IO阻塞存在,或则高延迟的IO程序中.遇到阻塞,线程会自动让出解释器.而在cpu密集型程序中,python线程效率低下

- GIL问题建议
    - 尽量使用多进程完成并发
    - 不使用c作为解释器情况没有GIL问题
    - 使用多种阻塞方案完成并发