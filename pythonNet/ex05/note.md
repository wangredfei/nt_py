# 关于fork
- 子进程从fork的下一句开始执行
- 父子进程各自独立运行,运行顺序不一定
- if结构几乎是fork的固定搭配通过父子进程返回值的区别,使其执行不同的代码
- 子进程会复制父进程全部代码段和内存空间,包括fork前所开辟的空间
- 父子进程空间互不影响,各自修改各种空间内容
- 子进程也有子集独立的内容,比如PID指令集,PCB等

# 进程函数
## os.getpid()
- 功能: 获取当前进程的PID号
- 返回值: 返回PID

## os.getppid()
- 功能: 获取父进程的PID号
- 返回值: 返回PID

## os.exit(status)
- 功能: 退出进程
- 参数: 表示进程的突出状态

## sys.exit([status])
- 功能: 退出进程
- 参数: 整数 表示进程退出状态, 默认为0
    - 字符串 表示进程退出时打印字符串

## 孤儿进程
- 父进程先于子进程退出,此时子进程就成为孤儿进程
* 孤儿进程会被系统进程收养,即该系统进程成为孤儿进程新的父进程

## 僵尸进程
- 子进程先于父进程退出,且父进程没有处理子进程退出行为,此时子进程就会成为僵尸进程
* 僵尸进程虽然结束但是会存留部分进程信息在内存中,大量的僵尸进程会消耗系统资源,因此应该避免僵尸进程产生

## 如何处理僵尸进程
- 二级子进程

### `pid, status = os.wait()`
- 功能: 父进程中阻塞等待处理子进程的退出
- 返回值: pid 退出的子进程的pid号 \ status 子进程的退出状态
- 例子 child


### `pid, status = os.waitpid(pid, option)`
- 功能: 费进程中处理子进程的退出
- 参数: 
    - pid -1表示等待任意子进程退出  
            >0 表示等在对应PID的子进程退出
    - option 0 表示阻塞等待  
        os.WNOHANG 表示非阻塞
- 返回值: pid 退出的子进程的pid号 \ status 子进程的退出状态
-

# 群聊聊天室
- 功能: 类似QQ群聊
1. 进入聊天室需要输入姓名,姓名不能重复
2. 进入聊天室会向其他成员发送通知
    - xxx进入聊天室
3. 一个人发消息,其他人都会收到
    - xxx说: xxxx
4. 默认退出聊天室,其他人也会收到通知
    - xxx退出聊天室
5. 管理员可以从后台发送消息,此时群里人都收到
    - 管理员说:,,,xxxx

## 分析
- 


## 整体设计
1. 封装方式
2. 编写流程,先确保通信实现,再逐个功能实现
3. 测试  实现一个功能,测试一个功能

## 具体功能实现
- 网络通信  
    - 服务端 : 创建UDP套接字,绑定地址
    - 客户端 : 创建套接字

- 进入聊天室
    - 客户端:  
        1. 输入用户名  
        2. 将用户名发送给服务区
        3. 得到一个反馈  
            4. 如果不允许进入则重新输入姓名  
            5. 如果允许进入聊天室则进入聊天  
                6. 创建新的进程 一个用于接受, 一个用于发送
    - 服务团: 
        1. 接受表名
        2. 判断姓名是否存在
        3. 如果存在返回不许进入
        4. 如果不存在则将用户加入存储结构,并通知其他人登录信息 

    - 聊天:
        - 服务端 : 接收消息
	        -  转发消息

        - 客户端 : 输入消息
	        -  发送消息

    - 退出:
        - 服务端 :  接收退出请求
	        - 发送通知给其他人
		    - 给退出者发送EXIT
		    - 从user删除用户
	- 客户端 : 
        - 发送提出信息
	    - 父子进程退出

# 作业 :  
- 将一个文件使用父子进程进行复制父子进程分别复制文件的上下两部分到一个新的文件中按字节分割上下两部分

# 注意
- 如果子进程从父进程继承对象,则父子进程使用此对象可能会相互影响
- 但是如果对象是子进程创建后,在各自进程重生成的则一定没有影响